use crate::*;
use crate::parse::{Token, ParseError as E, ParseErrorKind as K};

grammar<'i>;

extern {
    type Location = usize;
    type Error = E;

    enum Token<'i> {
        NEWLINE => Token::Newline,
        NOSP => Token::Join,
        WORD => Token::Word(<&'i str>),
        STRING_FRAGMENT => Token::Verbatim(<&'i str>),
        "$VAR" => Token::Variable(<&'i str>),

        "if" => Token::If,
        "else" => Token::Else,
        "for" => Token::For,
        "in" => Token::In,
        "while" => Token::While,
        "break" => Token::Break,
        "continue" => Token::Continue,
        "function" => Token::Function,
        "return" => Token::Return,
        "begin" => Token::Begin,
        "end" => Token::End,
        "switch" => Token::Switch,
        "case" => Token::Case,
        "and" => Token::And,
        "or" => Token::Or,
        "not" => Token::Not,

        "$(" => Token::DollarLParen,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        ">" => Token::Gt,
        ">&" => Token::GtAmp,
        ">?" => Token::GtQus,
        "<" => Token::Lt,
        "<&" => Token::LtAmp,
        "<?" => Token::LtQus,
        ">>" => Token::GtGt,
        "?" => Token::Qus,
        "&" => Token::Amp,
        "|" => Token::Pipe,
        "&|" => Token::AmpPipe,
        ">|" => Token::GtPipe,
        ";" => Token::Semi,
        "*" => Token::Star,
        "**" => Token::StarStar,
        "~" => Token::Tilde,
        "\"" => Token::DQuote,
        "'" => Token::SQuote,
    }
}

pub SourceFile: SourceFile =
    <StmtList> => SourceFile { stmts: <> };

StmtList: Vec<Stmt> = {
    => Vec::new(),
    <Stmt> => vec![<>],
    <mut ls:StmtList> EOS <s:Stmt?> => { ls.extend(s); ls },
};

EOS: () = { NEWLINE, ";" };

Stmt: Stmt = {
    <StmtNoCond>,

    "and" <Stmt> => Stmt::And(<>.into()),
    "or" <Stmt> => Stmt::Or(<>.into()),
}

StmtNoCond: Stmt = {
    #[precedence(level = "0")]
    <Control> => <>,
    #[precedence(level = "0")]
    <Word+> => Stmt::Command(<>),

    #[precedence(level = "1")]
    <mut s:StmtNoCond> <r:Redirect> => {
        match &mut s {
            Stmt::Redirect(_, rs) => { rs.push(r); s },
            _ => Stmt::Redirect(s.into(), vec![r]),
        }
    },

    #[precedence(level = "2")]
    #[assoc(side = "right")]
    <lhs:StmtNoCond> <port:PipeOp> <rhs:StmtNoCond> => Stmt::Pipe(port, lhs.into(), rhs.into()),

    #[precedence(level = "3")]
    "not" <StmtNoCond> => Stmt::Not(<>.into()),
};

PipeOp: RedirectPort = {
    "|" => RedirectPort::STDOUT,
    "&|" => RedirectPort::STDOUT_STDERR,
    "&" NOSP <lpos:@L> <port:Word> <rpos:@R> ">|" =>? {
        match port {
            Word::Simple(port) => port.parse().ok(),
            _ => None,
        }
        .ok_or_else(|| E::new(lpos, rpos, K::InvalidRedirectPort).into())
    }
}

Redirect: Redirect = {
    <port:("&" NOSP <@L> <Word> NOSP <@R>)?> <mode:RedirectMode> NOSP <dest:Word> =>? {
        let port = match port {
            None => mode.default_port(),
            Some((lpos, port, rpos)) => {
                match port {
                    Word::Simple(port) => port.parse().ok(),
                    _ => None,
                }
                .ok_or_else(|| E::new(lpos, rpos, K::InvalidRedirectPort))?
            }
        };
        Ok(Redirect { port, mode, dest: RedirectDest::File(dest) })
    },
};
RedirectMode: RedirectMode = {
    "<"  => RedirectMode::Read,
    "<?" => RedirectMode::ReadOrNull,
    ">"  => RedirectMode::Write,
    ">?" => RedirectMode::WriteNoClobber,
    ">>" => RedirectMode::Append,
    // TODO: "<&", ">&"
};

StmtBlock: Stmt =
    <mut s:StmtList> => {
        if s.len() == 1 {
            s.pop().unwrap()
        } else {
            Stmt::Block(<>)
        }
    };

Control: Stmt = {
    "begin" EOS <StmtBlock> "end",
    <If> => <>,
    "for" <var:Word> "in" <seq:Word*> EOS <body:StmtBlock> "end" => Stmt::For(var, seq, body.into()),
    "while" <cond:Stmt> EOS <body:StmtBlock> "end" => Stmt::While(cond.into(), body.into()),
    "break" => Stmt::Break,
    "continue" => Stmt::Continue,
    "function" <def:Word*> EOS <body:StmtBlock> "end" => Stmt::Function(def, body.into()),
    "return" <Word?> => Stmt::Return(<>),
    "switch" <testee:Word> EOS <cases:SwitchCase*> "end" => Stmt::Switch(testee, cases),
};

If: Stmt = {
    "if" <cond:Stmt> EOS <then:StmtBlock> "end" =>
        Stmt::If(cond.into(), then.into(), None),
    "if" <cond:Stmt> EOS <then:StmtBlock> "else" <else_:If> "end" =>
        Stmt::If(cond.into(), then.into(), Some(else_.into())),
    "if" <cond:Stmt> EOS <then:StmtBlock> "else" EOS <else_:StmtBlock> "end" =>
        Stmt::If(cond.into(), then.into(), Some(else_.into())),
};

SwitchCase: SwitchCase =
    "case" <globs:Word*> EOS <body:StmtBlock> => SwitchCase { globs, body };

Word: Word = {
    <WordFrag> => Word::from(<>),
    <String> => Word::Complex(<>),
    <w:Word> NOSP <frag:WordFrag> => w.append(frag),
    <w:Word> NOSP <frags:String> => {
        let fs = match w {
            Word::Simple(w) => std::iter::once(WordFrag::Literal(w)).chain(frags).collect(),
            Word::Complex(mut fs) => { fs.extend(frags); fs },
        };
        Word::Complex(fs)
    }
};

WordFrag: WordFrag = {
    // TODO: "~"
    <WORD> => WordFrag::Literal(<>.into()),
    <"$VAR"> => WordFrag::Variable(<>.into()),
    "*" => WordFrag::Wildcard,
    "**" => WordFrag::WildcardRecursive,
    "$(" <StmtBlock> ")" => WordFrag::Command(<>),
    // "{"
};

String: Vec<WordFrag> = {
    "\"" <DQuoteFrag*> "\"" => <>,
    "'" <SQuoteFrag*> "'" => <>,
};
DQuoteFrag: WordFrag = {
    <"$VAR"> => WordFrag::VariableNoSplit(<>.into()),
    // $(
    <STRING_FRAGMENT> => WordFrag::Literal(<>.into()),
};
SQuoteFrag: WordFrag =
    <STRING_FRAGMENT> => WordFrag::Literal(<>.into());
