use crate::*;
use crate::parse::{Token, ParseError as E, ParseErrorKind as K};

grammar<'i>;

extern {
    type Location = usize;
    type Error = E;

    enum Token<'i> {
        NEWLINE => Token::Newline,
        NOSP => Token::Join,
        WORD => Token::Word(<&'i str>),
        STRING_FRAGMENT => Token::Verbatim(<&'i str>),
        "$VAR" => Token::Variable(<&'i str>),

        "if" => Token::If,
        "else" => Token::Else,
        "for" => Token::For,
        "in" => Token::In,
        "while" => Token::While,
        "break" => Token::Break,
        "continue" => Token::Continue,
        "function" => Token::Function,
        "return" => Token::Return,
        "begin" => Token::Begin,
        "end" => Token::End,
        "switch" => Token::Switch,
        "case" => Token::Case,
        "and" => Token::And,
        "or" => Token::Or,
        "not" => Token::Not,

        "$(" => Token::DollarLParen,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        ">" => Token::Gt,
        ">&" => Token::GtAmp,
        ">?" => Token::GtQus,
        "<" => Token::Lt,
        "<&" => Token::LtAmp,
        "<?" => Token::LtQus,
        ">>" => Token::GtGt,
        "?" => Token::Qus,
        "&" => Token::Amp,
        "|" => Token::Pipe,
        "&|" => Token::AmpPipe,
        ">|" => Token::GtPipe,
        ";" => Token::Semi,
        "*" => Token::Star,
        "**" => Token::StarStar,
        "~" => Token::Tilde,
        "~/" => Token::TildeSlash,
        "\"" => Token::DQuote,
        "'" => Token::SQuote,
    }
}

pub SourceFile: SourceFile =
    <StmtList> => SourceFile { stmts: <> };

StmtList: Vec<Stmt> = {
    => Vec::new(),
    <Stmt> => vec![<>],
    <mut ls:StmtList> EOS <s:Stmt?> => { ls.extend(s); ls },
};

EOS: () = { NEWLINE, ";" };

Stmt: Stmt = {
    #[precedence(level = "0")]
    <Control> => <>,
    #[precedence(level = "0")]
    <pos:@L> <ws:Word+> => Stmt::Command(pos as _, ws),

    #[precedence(level = "1")]
    <pos:@L> <mut s:Stmt> <r:Redirect> => {
        match &mut s {
            Stmt::Redirect(_, _, rs) => { rs.push(r); s },
            _ => Stmt::Redirect(pos as _, s.into(), vec![r]),
        }
    },

    #[precedence(level = "2")]
    #[assoc(side = "right")]
    <lhs:Stmt> <pos:@L> <port:PipeOp> <mut rhs:Stmt> => {
        match &mut rhs {
            Stmt::Pipe(_, pipes, _) => {
                // FIXME: O(n^2) time.
                pipes.insert(0, (lhs, port));
                rhs
            }
            _ => Stmt::Pipe(pos as _, vec![(lhs, port)], rhs.into()),
        }
    },

    #[precedence(level = "3")]
    <pos:@L> "not" <s:Stmt> => Stmt::Not(pos as _, s.into()),

    #[precedence(level = "3")]
    <pos:@L> "and" <s:Stmt> => Stmt::And(pos as _, s.into()),
    #[precedence(level = "3")]
    <pos:@L> "or" <s:Stmt> => Stmt::Or(pos as _, s.into()),
};

PipeOp: RedirectPort = {
    "|" => RedirectPort::STDOUT,
    "&|" => RedirectPort::STDOUT_STDERR,
    "&" NOSP <lpos:@L> <port:Word> <rpos:@R> ">|" =>? {
        match port {
            Word::Simple(port) => port.parse().ok(),
            _ => None,
        }
        .ok_or_else(|| E::new(lpos, rpos, K::InvalidRedirectPort).into())
    }
}

Redirect: Redirect = {
    <port:("&" NOSP <@L> <WordJoined> NOSP <@R>)?> <mode:RedirectMode> NOSP <dest:Word> =>? {
        let port = match port {
            None => mode.default_port(),
            Some((lpos, port, rpos)) => {
                match port {
                    Word::Simple(port) => port.parse().ok(),
                    _ => None,
                }
                .ok_or_else(|| E::new(lpos, rpos, K::InvalidRedirectPort))?
            }
        };
        Ok(Redirect { port, mode, dest: RedirectDest::File(dest) })
    },
};
RedirectMode: RedirectMode = {
    "<"  => RedirectMode::Read,
    "<?" => RedirectMode::ReadOrNull,
    ">"  => RedirectMode::Write,
    ">?" => RedirectMode::WriteNoClobber,
    ">>" => RedirectMode::Append,
    // TODO: "<&", ">&"
};

StmtBlock: Stmt =
    <pos:@L> <ls:StmtList> => Stmt::Block(pos as _, ls);

Control: Stmt = {
    <pos:@L> "begin" EOS <ls:StmtList> "end" => Stmt::Block(pos as _, ls),
    <If> => <>,
    <pos:@L> "for" <var:Word> "in" <seq:Word*> EOS <body:StmtBlock> "end" => Stmt::For(pos as _, var, seq, body.into()),
    <pos:@L> "while" <cond:Stmt> EOS <body:StmtBlock> "end" => Stmt::While(pos as _, cond.into(), body.into()),
    <pos:@L> "break" => Stmt::Break(pos as _),
    <pos:@L> "continue" => Stmt::Continue(pos as _),
    <pos:@L> "function" <def:Word*> EOS <body:StmtBlock> "end" => Stmt::Function(pos as _, def, body.into()),
    <pos:@L> "return" <w:Word?> => Stmt::Return(pos as _, w),
    <pos:@L> "switch" <testee:Word> EOS <cases:SwitchCase*> "end" => Stmt::Switch(pos as _, testee, cases),
};

If: Stmt = {
    <pos:@L> "if" <cond:Stmt> EOS <then:StmtBlock> "end" =>
        Stmt::If(pos as _, cond.into(), then.into(), None),
    <pos:@L> "if" <cond:Stmt> EOS <then:StmtBlock> "else" <else_:If> "end" =>
        Stmt::If(pos as _, cond.into(), then.into(), Some(else_.into())),
    <pos:@L> "if" <cond:Stmt> EOS <then:StmtBlock> "else" EOS <else_:StmtBlock> "end" =>
        Stmt::If(pos as _, cond.into(), then.into(), Some(else_.into())),
};

SwitchCase: SwitchCase =
    "case" <globs:Word*> EOS <body:StmtBlock> => SwitchCase { globs, body };

Word: Word = {
    "~" => Word::Complex(vec![WordFrag::Home { slash: false }]),
    <WordJoined>,
};

WordJoined: Word = {
    <WordFrag> => Word::from(<>),
    <String> => Word::Complex(<>),
    <w:WordJoined> NOSP <frag:WordFrag> => w.append(frag),
    <w:WordJoined> NOSP <frags:String> => {
        let fs = match w {
            Word::Simple(w) => std::iter::once(WordFrag::Literal(w)).chain(frags).collect(),
            Word::Complex(mut fs) => { fs.extend(frags); fs },
        };
        Word::Complex(fs)
    }
};

WordFrag: WordFrag = {
    "~/" => WordFrag::Home { slash: true },
    <WORD> => WordFrag::Literal(<>.into()),
    <"$VAR"> => WordFrag::Variable(<>.into()),
    "*" => WordFrag::Wildcard,
    "**" => WordFrag::WildcardRecursive,
    "$(" <StmtBlock> ")" => WordFrag::Command(<>),
    "(" <StmtBlock> ")" => WordFrag::Command(<>),
    // TODO: "{"
};

String: Vec<WordFrag> = {
    "\"" <DQuoteFrag*> "\"" => <>,
    "'" <SQuoteFrag*> "'" => <>,
};
DQuoteFrag: WordFrag = {
    <"$VAR"> => WordFrag::VariableNoSplit(<>.into()),
    "$(" <StmtBlock> ")" => WordFrag::CommandNoSplit(<>),
    <STRING_FRAGMENT> => WordFrag::Literal(<>.into()),
};
SQuoteFrag: WordFrag =
    <STRING_FRAGMENT> => WordFrag::Literal(<>.into());
